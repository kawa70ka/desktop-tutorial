<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>テキスト整理ツール</title>
    <style>
        /* 既存のCSSはそのまま */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #495057;
            margin-bottom: 20px;
        }
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 16px;
            box-sizing: border-box;
            resize: vertical;
        }
        /* 各入力欄の高さ調整 */
        #inputRawText, #inputPreProcessedText {
            height: 150px;
            margin-bottom: 15px;
        }
        #inputText {
            height: 250px;
            margin-bottom: 15px;
        }
        #outputText {
            height: 350px;
            background-color: #e9ecef;
            cursor: copy;
        }
        button {
            display: block;
            width: 100%;
            padding: 12px;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 20px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0056b3;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #495057;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>テキスト整理ツール</h1>

        <label for="inputRawText">（1段階目）生のテキスト入力欄</label>
        <textarea id="inputRawText" placeholder="ここに生のテキストを貼り付けてください..."></textarea>
        <button id="processStage1Button">1段階目の整理を実行</button>

        <label for="inputPreProcessedText">（2段階目）中間処理済みテキスト</label>
        <textarea id="inputPreProcessedText" readonly placeholder="1段階目の結果がここに表示されます..."></textarea>
        <button id="processStage2Button">2段階目の整理を実行</button>

        <label for="inputText">（3段階目）最終入力欄</label>
        <textarea id="inputText" readonly placeholder="2段階目の結果がここに表示されます..."></textarea>
        <button id="processStage3Button">3段階目の整理を実行</button>

        <label for="outputText">出力欄（クリックしてコピー）</label>
        <textarea id="outputText" readonly placeholder="整理されたテキストがここに表示されます..."></textarea>
    </div>

    <script>
        document.getElementById('processStage1Button').addEventListener('click', processStage1);
        document.getElementById('processStage2Button').addEventListener('click', processStage2);
        document.getElementById('processStage3Button').addEventListener('click', processStage3);
        document.getElementById('outputText').addEventListener('click', (e) => {
            e.target.select();
            document.execCommand('copy');
            alert('出力結果をコピーしました。');
        });

        // ==============================
        // 第1段階の整理ロジック
        // 目的: 「人の名前」と「#番号」を残す。「チーム」「TEAM」「テンポ」「TEMPO」「2min」「ツーミニ」は#番号の中にあれば残す。
        // ==============================
        function processStage1() {
            const inputRawText = document.getElementById('inputRawText').value;
            const lines = inputRawText.split('\n');
            let outputLines = [];

            const retainedWordsRegex = /(チーム|TEAM|テンポ|TEMPO|2min|ツーミニ)/gi;

            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (!trimmedLine) return;

                // 1. #番号を含む行の処理
                const commentMatch = trimmedLine.match(/^(.*?)(#\d+\s*.+)$/);
                if (commentMatch) {
                    // #番号の前の部分（名前など）を抽出
                    let preCommentPart = commentMatch[1].trim();
                    // #番号以降の部分（コメント本文）を抽出
                    let commentPart = commentMatch[2].trim();

                    // コメント本文に保持したいキーワードが含まれているかチェック
                    // 例: "#1 ラッドキラーします、ラベンダーミスりました" -> これ全体は残したい
                    // 例: "うんこ #1 ラッドキラーします" -> "うんこ"は削除、"#1 ラッドキラーします"は残す
                    // ただし、今回は「コメント部分」にキーワードがあれば残すなので、ここでは `retainedWordsRegex` を使わない

                    // 前の行が名前だった場合でも、#コメント行はそのまま残したい。
                    // 名前らしき文字列であればそのままとする
                    // 特定のパターン（タイムスタンプなど）だけを削除する
                    // formatName関数を流用して、余分な情報を削除
                    preCommentPart = formatNameStage1(preCommentPart);

                    // #コメントはそのまま残す
                    outputLines.push(preCommentPart + commentPart);

                } else {
                    // 2. #番号を含まない行の処理
                    // 人の名前または保持したいキーワードのみを残す
                    const potentialName = formatNameStage1(trimmedLine);
                    const retainedWordMatch = trimmedLine.match(retainedWordsRegex);

                    if (potentialName) {
                        outputLines.push(potentialName);
                    } else if (retainedWordMatch) {
                        outputLines.push(retainedWordMatch[0]);
                    }
                    // その他の行は削除（スキップ）
                }
            });

            document.getElementById('inputPreProcessedText').value = outputLines.filter(Boolean).join('\n');
            document.getElementById('outputText').value = '';
        }

        // Stage 1 専用のformatName関数
        // 主にタイムスタンプや不要なアーティファクトを削除し、名前またはそのままのテキストを返す
        function formatNameStage1(rawText) {
            let text = rawText.trim();

            if (text.startsWith('#') || text.includes('（編集済み）') || text.includes('件の返信') || text.includes('スレッドを表示する') || /^\d{1,2}:\d{2}$/.test(text) || /^\d{1,2}\/\d{1,2}$/.test(text)) {
                return '';
            }

            // より積極的なタイムスタンプやSlack関連の文字の削除
            text = text.replace(/\s*\(\d{1,2}:\d{2}\).*$/, '');
            text = text.replace(/\s+\d{1,2}:\d{2}(?:\s+\d{1,2}\/\d{1,2})?.*$/, '');
            text = text.replace(/\s+\d{1,2}\/\d{1,2}\s+\d{1,2}:\d{2}.*$/, '');
            text = text.replace(/\s*\(編集済み\).*$/, '');
            text = text.replace(/\s*\d+\s*件の返信.*$/, '');
            text = text.replace(/\s*今日\s+\d{1,2}:\d{2}.*$/, '');
            text = text.replace(/\s*スレッドを表示する.*$/, '');
            text = text.replace(/:\w+:/g, '');
            text = text.replace(/\s+\d+$/, '');
            text = text.replace(/^New\s+/, '');

            text = text.trim();

            // 残すべきキーワードはここで確認しない。
            // 人の名前らしきもの、またはコメント前の文字列なら残す。
            // 日本語の名前や英数字を含む文字列であれば残す
            if (text && !/^[0-9\s\/:.,!@#$%^&*()_=\[\]{};'"\\|,.<>/?`~]+$/.test(text)) {
                return text;
            }

            return '';
        }


        // ==============================
        // 第2段階の整理ロジック
        // 目的: 「チーム」「TEAM」「テンポ」「TEMPO」「2min」「ツーミニ」があれば、それをコメントの最初につける。
        //       単語の統一変換も行う。
        // ==============================
        function processStage2() {
            const inputPreProcessedText = document.getElementById('inputPreProcessedText').value;
            const lines = inputPreProcessedText.split('\n');
            let outputLines = [];

            const specialWords = ['チーム', 'TEAM', 'テンポ', 'TEMPO', '2min', 'ツーミニ'];
            let currentPrefix = ''; // 特殊なキーワードを保持する変数

            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (!trimmedLine) {
                    outputLines.push(''); // 空行はそのまま保持
                    return;
                }

                // 行頭が # の場合
                if (trimmedLine.startsWith('#')) {
                    if (currentPrefix) {
                        const match = trimmedLine.match(/^(#\d+)\s*(.*)$/);
                        if (match) {
                            // 修正点: currentPrefixをそのまま使う
                            outputLines.push(`${match[1]}（${currentPrefix}）${match[2].trim()}`);
                        } else {
                            outputLines.push(`（${currentPrefix}）${trimmedLine}`);
                        }
                    } else {
                        outputLines.push(trimmedLine);
                    }
                } else {
                    // 行頭が # ではない場合
                    const foundSpecialWord = specialWords.find(word => trimmedLine.includes(word));
                    if (foundSpecialWord) {
                        // ここから修正点: キーワードを統一形式に変換
                        let convertedWord = foundSpecialWord;
                        if (convertedWord === 'チーム' || convertedWord === 'team') {
                            convertedWord = 'TEAM';
                        } else if (convertedWord === 'ツーミニ' || convertedWord === '2min') {
                            convertedWord = '2MIN';
                        }
                        // 'テンポ'と'TEMPO'は既に指定のspecialWordsに含まれるため、ここでは変換不要

                        currentPrefix = convertedWord; // 変換後のキーワードを更新
                        // キーワード自体は出力しない（次のコメント行で利用するため）
                    } else {
                        // 特殊なキーワードが見つからない場合、その行をそのまま出力
                        outputLines.push(trimmedLine);
                        currentPrefix = ''; // キーワードをリセット
                    }
                }
            });

            document.getElementById('inputText').value = outputLines.join('\n');
            document.getElementById('outputText').value = ''; // 最終出力欄をクリア
        }

        // ==============================
        // 第3段階の整理ロジック (既存の organizeText をリネーム)
        // 目的: #番号でコメントをグループ化し、名前を紐付ける
        // ==============================
        function processStage3() {
            const inputText = document.getElementById('inputText').value;
            const lines = inputText.split('\n');
            const commentsByNumber = {};
            let currentName = '';

            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (!trimmedLine || trimmedLine.includes('（編集済み）') || trimmedLine.includes('件の返信') || trimmedLine.includes('スレッドを表示する')) {
                    return;
                }

                // Attempt to extract comments first
                const commentRegex = /#(\d+)\s*(.*?)(?=#|$)/g;
                let commentMatch;
                let commentsFoundInThisLine = [];
                while ((commentMatch = commentRegex.exec(trimmedLine)) !== null) {
                    commentsFoundInThisLine.push({
                        number: parseInt(commentMatch[1], 10),
                        text: commentMatch[2].trim()
                    });
                }

                // If no comments are found in this line, it's a potential name update.
                if (commentsFoundInThisLine.length === 0) {
                    // 2段階目で追加された接頭辞があれば取り除く
                    const cleanedLine = trimmedLine.replace(/^\s*（[^）]+）/, '').trim();
                    const potentialName = formatName(cleanedLine);
                    if (potentialName) {
                        currentName = potentialName;
                    }
                } else {
                    // If comments are found, use the currentName for them.
                    // Also, check if there's a name before the first comment in this line.
                    // 2段階目で追加された接頭辞があれば取り除く
                    const firstCommentIndex = trimmedLine.indexOf('#' + commentsFoundInThisLine[0].number);
                    if (firstCommentIndex > 0) {
                        const textBeforeFirstComment = trimmedLine.substring(0, firstCommentIndex).trim();
                        const cleanedTextBeforeComment = textBeforeFirstComment.replace(/^\s*（[^）]+）/, '').trim();
                        const potentialNameBeforeComment = formatName(cleanedTextBeforeComment);
                        if (potentialNameBeforeComment) {
                            currentName = potentialNameBeforeComment;
                        }
                    }
                }

                // Add the extracted comments with the currentName
                commentsFoundInThisLine.forEach(comment => {
                    if (comment.text) {
                        if (!commentsByNumber[comment.number]) {
                            commentsByNumber[comment.number] = [];
                        }
                        commentsByNumber[comment.number].push({
                            name: currentName,
                            text: comment.text
                        });
                    }
                });
            });

            // 結果を整形して出力
            const sortedKeys = Object.keys(commentsByNumber).sort((a, b) => a - b);
            let outputText = '';
            sortedKeys.forEach((key, index) => {
                if (index > 0) {
                    outputText += '\n';
                }
                outputText += `＃${key}\n`;
                commentsByNumber[key].forEach(entry => {
                    // Ensure displayName is not empty before adding to output
                    const displayName = entry.name ? entry.name : '不明な名前';
                    outputText += `${displayName}：${entry.text}\n`;
                });
            });

            document.getElementById('outputText').value = outputText;
        }

        // 既存のformatName関数 (これはstage3で使われるため、変更なし)
        function formatName(rawName) {
            let name = rawName.trim();

            if (name.startsWith('#')) {
                return '';
            }

            name = name.replace(/^New\s+/, '');
            name = name.replace(/\s+\d{1,2}:\d{2}(?:\s+\d{1,2}\/\d{1,2})?.*$/, '');
            name = name.replace(/\s+\d{1,2}\/\d{1,2}\s+\d{1,2}:\d{2}.*$/, '');
            name = name.replace(/\s*\(編集済み\).*$/, '');
            name = name.replace(/\s*\d+\s*件の返信.*$/, '');
            name = name.replace(/\s*今日\s+\d{1,2}:\d{2}.*$/, '');
            name = name.replace(/\s*スレッドを表示する.*$/, '');
            name = name.replace(/:\w+:/g, '');
            name = name.replace(/\s+\d+$/, '');

            name = name.trim();

            if (!name || /^[0-9\s\/:.,!@#$%^&*()_=\[\]{};'"\\|,.<>/?`~]+$/.test(name) || /^\d{1,2}:\d{2}$/.test(name) || /^\d{1,2}\/\d{1,2}$/.test(name)) {
                return '';
            }

            if (name === 'チーム' || name === 'テンポ' || name === '2min' || name === 'ツーミニ' || name === 'TEAM' || name === 'TEMPO') {
                return name;
            }

            const japaneseNameMatch = name.match(/^[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF\s]+/);
            if (japaneseNameMatch && japaneseNameMatch[0].trim().length > 0) {
                let extractedName = japaneseNameMatch[0].trim();
                const trailingWordsToRemove = ['vs立教', 'セルフレビューRG', 'Y', 'センター', '左右タックル'];
                for (const word of trailingWordsToRemove) {
                    if (extractedName.endsWith(word)) {
                        extractedName = extractedName.substring(0, extractedName.length - word.length).trim();
                    }
                }
                return extractedName;
            }

            return name;
        }
    </script>
</body>
</html>
