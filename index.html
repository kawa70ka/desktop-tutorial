<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>セルフレビュー整理ツール</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #3498db; /* Pop Blue */
            --secondary-color: #2ecc71; /* Pop Green */
            --bg-color: #f4f7f6; /* Light Grayish Blue */
            --text-color: #333333; /* Dark Gray */
            --container-bg: #ffffff; /* White */
            --border-color: #dddddd; /* Light Gray */
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 2rem;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            max-width: 900px;
            background: var(--container-bg);
            padding: 2.5rem 3rem;
            border-radius: 16px;
            box-shadow: 0 4px 20px var(--shadow-color);
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .container:hover {
            box-shadow: 0 8px 30px rgba(52, 152, 219, 0.2);
        }

        h1 {
            text-align: center;
            color: var(--text-color);
            font-weight: 700;
            margin-bottom: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: none;
        }

        h1 i {
            margin-right: 15px;
            font-size: 2.2rem;
            color: var(--primary-color);
        }

        textarea {
            width: 100%;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
            resize: vertical;
            background-color: #fdfdfd;
            color: var(--text-color);
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }

        #inputRawText {
            height: 150px;
            margin-bottom: 1rem;
        }

        .hero-image {
            width: 100%;
            height: 150px; /* Reduced height */
            object-fit: contain;
            border-radius: 16px;
            margin-bottom: 1.5rem; /* Adjusted margin */
            box-shadow: 0 4px 20px var(--shadow-color);
        }

        

        #outputText, #outputSortedText {
            height: 280px;
            cursor: pointer;
            background-color: #f8f9fa;
            transition: background-color 0.3s;
        }

        #outputText:hover, #outputSortedText:hover {
            background-color: #f1f3f5;
        }

        button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 14px;
            font-size: 18px;
            font-weight: 500;
            color: #ffffff;
            background: var(--primary-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 2rem;
            transition: all 0.3s ease;
            text-shadow: none;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(52, 152, 219, 0.4);
            background: #2980b9;
        }

        button i {
            margin-right: 10px;
        }

        label {
            display: block;
            margin-bottom: 0.8rem;
            font-weight: 500;
            color: var(--text-color);
            font-size: 1.1rem;
            text-shadow: none;
        }

        .description {
            font-size: 0.95rem;
            color: #555;
            background-color: #eaf2f8;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            line-height: 1.7;
            border-left: 4px solid var(--primary-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="Panthers%2070th%20logo.avif" alt="Team Logo" class="hero-image">
        <h1><i class="fas fa-football-ball"></i>セルフレビュー整理ツール</h1>

        <label for="inputRawText"><i class="fas fa-stream"></i> レビューテキスト入力</label>
        <p class="description">
            Slackなどからコピーした生のレビューテキストを貼り付けて「整理を実行」ボタンを押してください。<br>
            タイムスタンプ等の不要な情報を削除し、キーワード（チーム、テンポ等）を正規化し、#番号ごとにコメントをグループ化して出力します。
        </p>

        <b>入力例：</b>
        <pre style="background-color: #f8f9fa; padding: 10px; border-radius: 5px; white-space: pre-wrap; border: 1px solid #dddddd; margin-top: 0.5rem; margin-bottom: 1.5rem;">山田 太郎 14:20
#1 今のプレー、良かったと思う。

佐藤 次郎 14:21
#1 ナイスラン！中央突破が効いてた。

山田 太郎 14:22
チーム
#3 次のディフェンス、もっとラインを押し上げたい。</pre>

        <b>出力例：</b>
        <pre style="background-color: #f8f9fa; padding: 10px; border-radius: 5px; white-space: pre-wrap; border: 1px solid #dddddd; margin-top: 0.5rem; margin-bottom: 1.5rem;">＃1
山田 太郎：今のプレー、良かったと思う。
佐藤 次郎：ナイスラン！中央突破が効いてた。

＃3
山田 太郎：（TEAM）次のディフェンス、もっとラインを押し上げたい。</pre>

        <p class="description" style="border-left-color: #f39c12; background-color: #fef9e7; color: #c24914;">
            <b><i class="fas fa-exclamation-triangle"></i> 注意点</b><br>
            ＃の上の行にある文字列が名前と認識されるので＃の上には、TEAM、TEMPO、2min以外の文字は入れないでください。
        </p>
        <textarea id="inputRawText" placeholder="ここに生のテキストを貼り付けてください..."></textarea>
        <button id="processButton"><i class="fas fa-cogs"></i> 整理を実行</button>

        <label for="outputText"><i class="fas fa-copy"></i> 出力結果（クリックしてコピー）</label>
        <textarea id="outputText" readonly placeholder="整理されたテキストがここに表示されます..."></textarea>
        
        <label for="outputSortedText" style="margin-top: 2rem;"><i class="fas fa-sort-amount-down"></i> ソートされた出力結果（クリックしてコピー）</label>
        <textarea id="outputSortedText" readonly placeholder="ソートされたテキストがここに表示されます..."></textarea>
    </div>

    <script>
        document.getElementById('processButton').addEventListener('click', processAllStages);
        
        document.getElementById('outputText').addEventListener('click', (e) => {
            if(!e.target.value) return;
            e.target.select();
            document.execCommand('copy');
            alert('出力結果をコピーしました。');
        });

        document.getElementById('outputSortedText').addEventListener('click', (e) => {
            if(!e.target.value) return;
            e.target.select();
            document.execCommand('copy');
            alert('ソートされた出力結果をコピーしました。');
        });

        function processAllStages() {
            const inputRawText = document.getElementById('inputRawText').value;
            const stage1Result = processStage1(inputRawText);
            const stage2Result = processStage2(stage1Result);
            const stage3Result = processStage3(stage2Result);
            document.getElementById('outputText').value = stage3Result;

            const sortedResult = processAndSortOutput(stage3Result);
            document.getElementById('outputSortedText').value = sortedResult;
        }

        // ==============================
        // 新しいソート処理
        // ==============================
        function processAndSortOutput(inputText) {
            if (!inputText.trim()) {
                return "";
            }

            // 1. `outputText` の内容を解析し、個別のコメントオブジェクトの配列を作成する
            const lines = inputText.trim().split('\n');
            const parsedComments = [];
            let currentNumber = -1;

            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (!trimmedLine) return;

                const numberMatch = trimmedLine.match(/^＃(\d+)/);
                if (numberMatch) {
                    currentNumber = parseInt(numberMatch[1], 10);
                } else {
                    const commentMatch = trimmedLine.match(/^(.*?)[：](.*)$/); // 全角コロンで分割
                    if (commentMatch && currentNumber !== -1) {
                        parsedComments.push({
                            number: currentNumber,
                            name: commentMatch[1].trim(),
                            textWithTag: commentMatch[2].trim()
                        });
                    }
                }
            });

            // 2. 各コメントをカテゴリ分けし、タグを削除したテキストを作成する
            const categoryKeywords = {
                TEAM: ['（TEAM）', '（チーム）'],
                'ツーミニ': ['（2MIN）', '（ツーミニ）', '（ツーミニッツ）'],
                'テンポ': ['（TEMPO）', '（テンポ）']
            };

            const categorizedComments = parsedComments.map(comment => {
                let assignedCategory = 'TEAM'; // デフォルトカテゴリ
                let found = false;

                for (const [category, keywords] of Object.entries(categoryKeywords)) {
                    for (const keyword of keywords) {
                        if (comment.textWithTag.includes(keyword)) {
                            assignedCategory = category;
                            found = true;
                            break;
                        }
                    }
                    if (found) break;
                }
                
                const cleanedText = comment.textWithTag.replace(/（(TEAM|チーム|2MIN|ツーミニ|ツーミニッツ|TEMPO|テンポ)）/g, '').trim();

                return { ...comment, category: assignedCategory, text: cleanedText };
            });

            // 3. コメントをカテゴリごとにグループ化する
            const commentsByCategory = {
                TEAM: [],
                'ツーミニ': [],
                'テンポ': []
            };
            categorizedComments.forEach(c => {
                if (commentsByCategory[c.category]) {
                    commentsByCategory[c.category].push(c);
                }
            });

            // 4. 最終的な出力文字列を生成する
            let outputText = '';
            const categoryOrder = ['TEAM', 'ツーミニ', 'テンポ'];

            categoryOrder.forEach(categoryName => {
                const categoryComments = commentsByCategory[categoryName];
                if (!categoryComments || categoryComments.length === 0) return;

                outputText += `--- ${categoryName} ---\n\n`;

                // カテゴリ内でコメントを番号ごとにグループ化
                const commentsByNumber = {};
                categoryComments.forEach(c => {
                    if (!commentsByNumber[c.number]) {
                        commentsByNumber[c.number] = [];
                    }
                    commentsByNumber[c.number].push(c);
                });

                // 番号でソートして整形
                const sortedKeys = Object.keys(commentsByNumber).sort((a, b) => a - b);
                
                const formattedBlocks = sortedKeys.map(key => {
                    let blockText = `＃${key}\n`;
                    blockText += commentsByNumber[key].map(entry => `${entry.name}：${entry.text}`).join('\n');
                    return blockText;
                });

                outputText += formattedBlocks.join('\n\n');
                outputText += '\n\n';
            });

            return outputText.trim();
        }


        // ==============================
        // 第1段階の整理ロジック
        // ==============================
        function processStage1(inputRawText) {
            const lines = inputRawText.split('\n');
            let outputLines = [];

            const retainedWordsRegex = /(チーム|TEAM|テンポ|TEMPO|2min|ツーミニ)/gi;

            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (!trimmedLine) return;

                const commentMatch = trimmedLine.match(/^(.*?)(#\d+\s*.+)$/);
                if (commentMatch) {
                    let preCommentPart = commentMatch[1].trim();
                    let commentPart = commentMatch[2].trim();
                    preCommentPart = formatNameStage1(preCommentPart);
                    outputLines.push(preCommentPart + commentPart);
                } else {
                    const potentialName = formatNameStage1(trimmedLine);
                    const retainedWordMatch = trimmedLine.match(retainedWordsRegex);

                    if (potentialName) {
                        outputLines.push(potentialName);
                    } else if (retainedWordMatch) {
                        outputLines.push(retainedWordMatch[0]);
                    }
                }
            });

            return outputLines.filter(Boolean).join('\n');
        }

        function formatNameStage1(rawText) {
            let text = rawText.trim();
            if (text.startsWith('#') || text.includes('（編集済み）') || text.includes('件の返信') || text.includes('スレッドを表示する') || /^\d{1,2}:\d{2}$/.test(text) || /^\d{1,2}\/\d{1,2}$/.test(text)) {
                return '';
            }
            text = text.replace(/\s*\(\d{1,2}:\d{2}\).*$/, '');
            text = text.replace(/\s+\d{1,2}:\d{2}(?:\s+\d{1,2}\/\d{1,2})?.*$/, '');
            text = text.replace(/\s+\d{1,2}\/\d{1,2}\s+\d{1,2}:\d{2}.*$/, '');
            text = text.replace(/\s*\(編集済み\).*$/, '');
            text = text.replace(/\s*\d+\s*件の返信.*$/, '');
            text = text.replace(/\s*今日\s+\d{1,2}:\d{2}.*$/, '');
            text = text.replace(/\s*スレッドを表示する.*$/, '');
            text = text.replace(/:\w+:/g, '');
            text = text.replace(/\s+\d+$/, '');
            text = text.replace(/^New\s+/, '');
            text = text.trim();
            if (text && !/^[0-9\s\/:.,!@#$%^&*()_=\[\]{};'"\\|,.<>/?`~]+$/.test(text)) {
                return text;
            }
            return '';
        }

        // ==============================
        // 第2段階の整理ロジック
        // ==============================
        function processStage2(inputPreProcessedText) {
            const lines = inputPreProcessedText.split('\n');
            let outputLines = [];
            const specialWords = ['チーム', 'TEAM', 'テンポ', 'TEMPO', '2min', 'ツーミニ', 'ツーミニッツ'];
            const wordToPrefix = {
                'チーム': 'TEAM', 'team': 'TEAM',
                'テンポ': 'TEMPO', 'tempo': 'TEMPO',
                '2min': '2MIN', 'ツーミニ': '2MIN', 'ツーミニッツ': '2MIN'
            };

            let currentPrefix = ''; // Holds the state for the current person

            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (!trimmedLine) {
                    outputLines.push('');
                    return;
                }

                // Is it a keyword?
                const foundSpecialWord = specialWords.find(word => trimmedLine.toLowerCase() === word.toLowerCase());
                if (foundSpecialWord) {
                    currentPrefix = wordToPrefix[foundSpecialWord.toLowerCase()];
                    // Don't add the keyword line itself to the output
                    return;
                }

                // Is it a comment?
                if (trimmedLine.startsWith('#')) {
                    const prefixToUse = currentPrefix || 'TEAM'; // Default to TEAM
                    const match = trimmedLine.match(/^(#\d+)\s*(.*)$/);
                    if (match) {
                        outputLines.push(`${match[1]}（${prefixToUse}）${match[2].trim()}`);
                    } else {
                        outputLines.push(`（${prefixToUse}）${trimmedLine}`);
                    }
                } else {
                    // It's a name. Push it and reset the context for the next block of comments.
                    outputLines.push(trimmedLine);
                    currentPrefix = '';
                }
            });
            return outputLines.join('\n');
        }

        // ==============================
        // 第3段階の整理ロジック
        // ==============================
        function processStage3(inputText) {
            const lines = inputText.split('\n');
            const commentsByNumber = {};
            let currentName = '';

            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (!trimmedLine) return;

                const commentRegex = /#(\d+)\s*(.*?)(?=#|$)/g;
                let commentMatch;
                let commentsFoundInThisLine = [];
                while ((commentMatch = commentRegex.exec(trimmedLine)) !== null) {
                    commentsFoundInThisLine.push({
                        number: parseInt(commentMatch[1], 10),
                        text: commentMatch[2].trim()
                    });
                }

                if (commentsFoundInThisLine.length === 0) {
                    const cleanedLine = trimmedLine.replace(/^\s*（[^）]+）/, '').trim();
                    const potentialName = formatName(cleanedLine);
                    if (potentialName) {
                        currentName = potentialName;
                    }
                } else {
                    const firstCommentIndex = trimmedLine.indexOf('#' + commentsFoundInThisLine[0].number);
                    if (firstCommentIndex > 0) {
                        const textBeforeFirstComment = trimmedLine.substring(0, firstCommentIndex).trim();
                        const cleanedTextBeforeComment = textBeforeFirstComment.replace(/^\s*（[^）]+）/, '').trim();
                        const potentialNameBeforeComment = formatName(cleanedTextBeforeComment);
                        if (potentialNameBeforeComment) {
                            currentName = potentialNameBeforeComment;
                        }
                    }
                }

                commentsFoundInThisLine.forEach(comment => {
                    if (comment.text) {
                        if (!commentsByNumber[comment.number]) {
                            commentsByNumber[comment.number] = [];
                        }
                        commentsByNumber[comment.number].push({
                            name: currentName,
                            text: comment.text
                        });
                    }
                });
            });

            const sortedKeys = Object.keys(commentsByNumber).sort((a, b) => a - b);
            let outputText = '';
            sortedKeys.forEach((key, index) => {
                if (index > 0) {
                    outputText += '\n\n';
                }
                outputText += `＃${key}\n`;
                commentsByNumber[key].forEach(entry => {
                    const displayName = entry.name ? entry.name : '不明な名前';
                    outputText += `${displayName}：${entry.text}\n`;
                });
            });
            return outputText.trim();
        }

        function formatName(rawName) {
            let name = rawName.trim();
            if (name.startsWith('#')) return '';
            name = name.replace(/^New\s+/, '');
            name = name.replace(/\s+\d{1,2}:\d{2}(?:\s+\d{1,2}\/\d{1,2})?.*$/, '');
            name = name.replace(/\s+\d{1,2}\/\d{1,2}\s+\d{1,2}:\d{2}.*$/, '');
            name = name.replace(/\s*\(編集済み\).*$/, '');
            name = name.replace(/\s*\d+\s*件の返信.*$/, '');
            name = name.replace(/\s*今日\s+\d{1,2}:\d{2}.*$/, '');
            name = name.replace(/\s*スレッドを表示する.*$/, '');
            name = name.replace(/:\w+:/g, '');
            name = name.replace(/\s+\d+$/, '');
            name = name.trim();
            if (!name || /^[0-9\s\/:.,!@#$%^&*()_=\[\]{};'"\\|,.<>/?`~]+$/.test(name) || /^\d{1,2}:\d{2}$/.test(name) || /^\d{1,2}\/\d{1,2}$/.test(name)) {
                return '';
            }
            if (['チーム', 'テンポ', '2min', 'ツーミニ', 'TEAM', 'TEMPO'].includes(name)) {
                return name;
            }
            const japaneseNameMatch = name.match(/^[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF\s]+/);
            if (japaneseNameMatch && japaneseNameMatch[0].trim().length > 0) {
                let extractedName = japaneseNameMatch[0].trim();
                const trailingWordsToRemove = ['vs立教', 'セルフレビューRG', 'Y', 'センター', '左右タックル'];
                for (const word of trailingWordsToRemove) {
                    if (extractedName.endsWith(word)) {
                        extractedName = extractedName.substring(0, extractedName.length - word.length).trim();
                    }
                }
                return extractedName;
            }
            return name;
        }
    </script>
</body>
</html>
